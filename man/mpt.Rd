% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mpt.R
\name{mpt}
\alias{mpt}
\title{Fit Bayesian MPT Models with brms & Stan}
\usage{
mpt(
  formula,
  data,
  tree,
  model,
  default_prior_intercept = "normal(0, 1)",
  default_prior_coef = "normal(0, 0.5)",
  default_priors = TRUE,
  ...
)
}
\arguments{
\item{formula}{Either a \code{formula} that is applied to each MPT model parameter
or a \code{mpt_formula} object (created by \code{\link[=mpt_formula]{mpt_formula()}}) specifying separate
formulas for each parameter. If a \code{formula}, the LHS needs to specify the
response variable.}

\item{data}{\code{data.frame} containing the variables in \code{formula}. Data needs to
be on an observation-level (i.e., each row is one response/observation) and
cannot be aggregated in any way.}

\item{tree}{one-sided formula or character specifying the variable in \code{data}
indicating the tree (or item type) of a given observation. The values of
the \code{tree} variable need to match the names of the trees in \code{model}. Can be
omitted for models with only one tree.}

\item{model}{\code{mpt_model} object as created by \code{\link[=make_mpt]{make_mpt()}}, ignored if
\code{formula} is an object of \code{mpt_formula}.}

\item{default_prior_intercept}{character string describing the prior applied
to the fixed-effect intercepts for each MPT model parameter on the
unconstrained scale (if \code{default_priors = TRUE}). The default, \code{"normal(0, 1)"} implies a flat prior on the MPT parameter scale.}

\item{default_prior_coef}{character string describing the prior applied to
the non-intercept fixed-effect parameters for each MPT model parameter on
the unconstrained scale (if \code{default_priors = TRUE}).}

\item{default_priors}{logical value indicating whether (the default, \code{TRUE})
or not (\code{FALSE}) the priors specified via the \code{default_prior_intercept} and
\code{default_prior_coef} argument should be applied.}

\item{...}{Further arguments passed to \code{\link[brms:brm]{brms::brm()}} such as \code{prior},
\code{chains}, \code{iter}, \code{warmup}, and \code{cores}.}
}
\value{
A fitted model object returned from \code{\link[brms:brm]{brms::brm()}} of class \code{brmsfit}
with additional class \code{mpt_fit} and some extra slots (i.e., \code{call},
\code{mpt_formula}, and \code{orig_data}). This object should seemlessly interact
with the \code{brms} ecosystem (e.g., can be used for obtaining posterior
predictive values and information criteria, see \code{Examples}).
}
\description{
Fit a Bayesian multinomial processing tree (MPT) model using \code{\link[brms:brm]{brms::brm()}}
(so ultimately \code{Stan}) to trial-level data, potentially including a
multilevel/hierarchical model structure. To fit an MPT, first create a model
object using \code{\link[=make_mpt]{make_mpt()}} and then pass the model object, the data, as well
as a \code{formula} providing a symbolic description of the regression (i.e.,
fixed-effect) and hierarchical (i.e., random-effect) structure. The returned
object can be used for model post-processing.
}
\examples{
\dontrun{
### Step 1: Specify model using make_mpt()
## model in easy format (with model specified as text)
## unsure-extended 2-high threshold model for recognition memory
u2htm <- "
# Old Items
Do + (1 - Do) * (1 - g1) * g2
(1 - Do) * g1
(1 - Do) * (1 - g1) * (1 - g2)

# New Items
(1 - Dn) * (1 - g1) * g2
(1 - Dn) * g1
Dn + (1 - Dn) * (1 - g1) * (1 - g2)
"

# need to specify tree names and category names for easy format
u2htsm_model <- make_mpt(text = u2htm, trees = c("old", "new"),
                         categories = rep(c("old", "unsure", "new"), 2))
u2htsm_model


### Step 2: Fit model with same formula for all model parameters

## we fit to data from Singmann, Kellen, & Klauer (2013, CogSci-Proc):
# Investigating the Other-Race Effect of Germans towards Turks and Arabs using
# Multinomial Processing Tree Models
# http://singmann.org/download/publications/SKK-CogSci2013.pdf
str(skk13)

## here we use simplified syntax without any random effects for fitting speed.
fit_fast <- mpt(resp ~ race, data = skk13, model = u2htsm_model,
                tree = "type",
                cores = min(c(4, parallel::detectCores()))) ## uses multicore
## a more appropriate formula would be: resp ~ race + (race|s|id) + (1|p|stim)
## (i.e., crossed-random effects and full correlations among random terms)

### Step 3: Inspect results
fit_fast # in output, no parameter name refers to first MPT parameter (here: Dn)

## Check model fit
ppp_test(fit_fast)

## we can use package emmeans for marginal effects of conditions for parameters
# Default is first MPT model parameter (here: Dn)
emmeans::emmeans(fit_fast, "race", type = "response")
# using the dpar argument, we can get output for any other model parameter
emmeans::emmeans(fit_fast, "race", type = "response", dpar = "Do")
emmeans::emmeans(fit_fast, "race", type = "response", dpar = "g1x")
emmeans::emmeans(fit_fast, "race", type = "response", dpar = "g2x")

## We can also use all brms post-processing
# information criteria (e.g., loo)
(loo_model <- loo(fit_fast))
# posterior predictive checks
pp_check(fit_fast, type = "bars_grouped", group = "mpt_tree", ndraws = 100)
# get posterior mean predictions
pepred <- posterior_epred(fit_fast)
str(pepred)  ## dimensions are: samples, observations, probability (in tree)

### Alternative Step 2: First specify formula, then fit model
## Step 2a: Specify formula for each parameter separately using mpt_formula()
## (formula could be different for each model parameter)
u2htm_formula <- mpt_formula(
  Do ~ race + (race|s|id) + (1|p|stim),
  Dn ~ race + (race|s|id) + (1|p|stim),
  g1x ~ race + (race|s|id) + (1|p|stim),
  g2x ~ race + (race|s|id) + (1|p|stim),
  response = ~ resp,
  model = u2htsm_model
)
u2htm_formula

## Step 2b: Fit model using formula (takes rather long)
fit_slow <- mpt(u2htm_formula, data = skk13,
                tree = "type",
                cores = min(c(4, parallel::detectCores()))) ## uses multicore
fit_slow
}
}
